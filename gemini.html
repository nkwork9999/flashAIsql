<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gemini Flash + DuckDB-Wasm Demo (Improved)</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: Arial, sans-serif;
        background: #f5f5f5;
        color: #333;
      }
      .container {
        display: flex;
        height: 100vh;
      }
      .sidebar {
        width: 300px;
        background: white;
        border-right: 1px solid #ddd;
        padding: 20px;
        overflow-y: auto;
      }
      .main-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      h1 {
        color: #333;
        margin-bottom: 20px;
        font-size: 20px;
        padding-bottom: 15px;
        border-bottom: 2px solid #555;
      }
      .section {
        margin: 20px 0;
        padding: 15px;
        background: #fafafa;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
      }
      h3 {
        margin-top: 0;
        margin-bottom: 12px;
        font-size: 14px;
        color: #555;
        font-weight: 600;
      }
      button {
        background: #555;
        color: white;
        border: none;
        padding: 8px 16px;
        cursor: pointer;
        font-size: 13px;
        margin: 5px 5px 5px 0;
        border-radius: 3px;
        transition: background 0.2s;
      }
      button:hover {
        background: #333;
      }
      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      button.danger {
        background: #d9534f;
      }
      button.danger:hover {
        background: #c9302c;
      }
      button.small {
        padding: 5px 10px;
        font-size: 12px;
      }
      button.export {
        background: #28a745;
      }
      button.export:hover {
        background: #218838;
      }
      input[type="text"],
      input[type="password"] {
        width: 100%;
        padding: 8px;
        border: 1px solid #ccc;
        font-size: 13px;
        margin: 8px 0;
        border-radius: 3px;
      }
      input[type="text"]:focus,
      input[type="password"]:focus {
        outline: none;
        border-color: #555;
      }
      .result {
        background: white;
        padding: 10px;
        margin-top: 10px;
        white-space: pre-wrap;
        font-family: monospace;
        font-size: 12px;
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #ddd;
        border-radius: 3px;
      }
      .loading {
        color: #666;
        font-style: italic;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
        font-size: 13px;
      }
      th,
      td {
        padding: 8px;
        text-align: left;
        border-bottom: 1px solid #ddd;
      }
      th {
        background: #555;
        color: white;
        font-weight: normal;
      }
      tr:hover {
        background: #f9f9f9;
      }
      .warning {
        background: #fffbf0;
        padding: 10px;
        margin: 15px 0;
        border-left: 3px solid #f90;
        font-size: 13px;
        border-radius: 3px;
      }
      .drop-zone {
        border: 2px dashed #ccc;
        border-radius: 4px;
        padding: 30px;
        text-align: center;
        background: white;
        margin: 10px 0;
        cursor: pointer;
        transition: all 0.3s;
      }
      .drop-zone:hover {
        border-color: #555;
        background: #fafafa;
      }
      .drop-zone.drag-over {
        border-color: #555;
        background: #e8f4f8;
      }
      .file-list {
        margin-top: 10px;
        padding: 10px;
        background: white;
        border: 1px solid #ddd;
        border-radius: 3px;
        max-height: 200px;
        overflow-y: auto;
      }
      .file-item {
        padding: 6px;
        margin: 3px 0;
        background: #f9f9f9;
        border-left: 3px solid #555;
        font-size: 12px;
        border-radius: 2px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .file-item button {
        padding: 3px 8px;
        font-size: 11px;
        margin: 0 2px;
      }
      .success {
        color: #5cb85c;
      }
      .info {
        color: #5bc0de;
      }
      .error {
        color: #d9534f;
      }
      .tabs {
        display: flex;
        background: white;
        border-bottom: 2px solid #ddd;
        padding: 0 20px;
      }
      .tab {
        padding: 15px 25px;
        cursor: pointer;
        border-bottom: 3px solid transparent;
        font-size: 14px;
        color: #666;
        transition: all 0.2s;
      }
      .tab:hover {
        background: #f9f9f9;
        color: #333;
      }
      .tab.active {
        color: #333;
        border-bottom-color: #555;
        font-weight: 600;
      }
      .tab-content {
        display: none;
        padding: 20px;
        overflow-y: auto;
        flex: 1;
        background: white;
      }
      .tab-content.active {
        display: block;
      }
      #initStatus {
        padding: 8px 12px;
        margin: 10px 0;
        background: #fffbf0;
        border-left: 3px solid #f90;
        font-size: 12px;
        border-radius: 3px;
      }
      .stat-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin: 15px 0;
      }
      .stat-card {
        background: #fafafa;
        padding: 15px;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
      }
      .stat-card h4 {
        font-size: 13px;
        color: #666;
        margin-bottom: 8px;
      }
      .stat-card .value {
        font-size: 24px;
        font-weight: bold;
        color: #333;
      }
      .column-info {
        background: #fafafa;
        padding: 12px;
        margin: 8px 0;
        border-left: 3px solid #555;
        border-radius: 3px;
      }
      .column-info h4 {
        font-size: 13px;
        margin-bottom: 8px;
        color: #333;
      }
      .column-detail {
        font-size: 12px;
        color: #666;
        margin: 4px 0;
      }
      .table-selector {
        margin-bottom: 15px;
      }
      .table-selector select {
        width: 100%;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 3px;
        font-size: 13px;
      }
      .export-section {
        margin-top: 15px;
        padding: 10px;
        background: #e8f5e9;
        border: 1px solid #4caf50;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="sidebar">
        <h1>DuckDB + Gemini</h1>

        <div id="initStatus">Initializing DuckDB-WASM...</div>

        <div class="warning">
          <strong>API Key Required:</strong>
          Get a Gemini API key from
          <a href="https://aistudio.google.com/app/apikey" target="_blank"
            >Google AI Studio</a
          >.
        </div>

        <div class="section">
          <h3>API Key Settings</h3>
          <input type="password" id="apiKey" placeholder="Enter your API key" />
          <button onclick="saveApiKey()">Save</button>
          <span id="apiKeyStatus"></span>
        </div>

        <div class="section">
          <h3>File Upload</h3>
          <div class="drop-zone" id="dropZone">
            <p>üìÅ CSV/Parquet</p>
            <p style="font-size: 11px; color: #666">
              Drag & drop or click to select
            </p>
          </div>
          <input
            type="file"
            id="fileInput"
            multiple
            accept=".csv,.parquet"
            style="display: none"
          />
          <div id="fileList" class="file-list" style="display: none"></div>
          <div id="loadResult" class="result" style="max-height: 150px"></div>
        </div>

        <div class="section export-section">
          <h3>üì• Export</h3>
          <select id="exportTableSelect">
            <option value="">Select a table...</option>
          </select>
          <div style="margin-top: 10px">
            <button onclick="exportToParquet()" class="export">
              Save as Parquet
            </button>
            <button onclick="exportToCSV()" class="export">Save as CSV</button>
          </div>
          <div id="exportStatus" style="margin-top: 10px"></div>
        </div>
      </div>

      <div class="main-content">
        <div class="tabs">
          <div class="tab active" onclick="switchTab('analysis')">
            üìä Data Analysis
          </div>
          <div class="tab" onclick="switchTab('sql')">üíª SQL Query</div>
          <div class="tab" onclick="switchTab('tables')">üìã Tables</div>
        </div>

        <div id="analysis" class="tab-content active">
          <h2 style="margin-bottom: 20px; font-size: 18px">Data Analysis</h2>
          <div class="table-selector">
            <select id="analysisTableSelect" onchange="loadTableAnalysis()">
              <option value="">Select a table...</option>
            </select>
          </div>
          <div id="analysisContent"></div>
        </div>

        <div id="sql" class="tab-content">
          <h2 style="margin-bottom: 20px; font-size: 18px">
            Execute SQL Query
          </h2>
          <div style="margin-bottom: 15px">
            <input
              type="text"
              id="sqlQuery"
              placeholder="SELECT * FROM table_name"
              value="SHOW TABLES"
            />
            <button onclick="executeQuery()">Execute</button>
            <button onclick="exportQueryResult()" class="export small">
              Save Results
            </button>
          </div>
          <div id="queryResult" class="result" style="max-height: none"></div>

          <h2 style="margin: 30px 0 20px; font-size: 18px">AI Analysis</h2>
          <div style="margin-bottom: 15px">
            <input
              type="text"
              id="analysisQuery"
              placeholder="SQL query to analyze"
              value="SHOW TABLES"
            />
            <button onclick="analyzeSQLWithGemini()">
              Fetch Data & Analyze with AI
            </button>
          </div>
          <div
            id="integrationResult"
            class="result"
            style="max-height: none"
          ></div>
        </div>

        <div id="tables" class="tab-content">
          <h2 style="margin-bottom: 20px; font-size: 18px">Loaded Tables</h2>
          <button onclick="refreshTableList()" class="small">üîÑ Refresh</button>
          <div id="tableListContent"></div>
        </div>
      </div>
    </div>

    <script type="module">
      import * as duckdb from "https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm/+esm";

      let db = null;
      let conn = null;
      let apiKey = "";
      const loadedFiles = new Set();
      let lastQueryResult = null;

      function updateInitStatus(message, isSuccess = false, isError = false) {
        const statusDiv = document.getElementById("initStatus");
        if (isSuccess) {
          statusDiv.style.background = "#d4edda";
          statusDiv.style.borderLeftColor = "#28a745";
          statusDiv.style.color = "#155724";
        } else if (isError) {
          statusDiv.style.background = "#f8d7da";
          statusDiv.style.borderLeftColor = "#dc3545";
          statusDiv.style.color = "#721c24";
        }
        statusDiv.textContent = message;
      }

      async function initDuckDB() {
        if (db && conn) {
          console.log("DuckDB already initialized");
          return;
        }

        try {
          updateInitStatus("Loading DuckDB-WASM module...");

          const bundle = await duckdb.selectBundle(duckdb.getJsDelivrBundles());

          updateInitStatus("Creating Worker...");

          const worker = new Worker(
            URL.createObjectURL(
              new Blob([`importScripts("${bundle.mainWorker}");`], {
                type: "text/javascript",
              })
            )
          );

          updateInitStatus("Creating DuckDB instance...");

          db = new duckdb.AsyncDuckDB(new duckdb.ConsoleLogger(), worker);
          await db.instantiate(bundle.mainModule, bundle.pthreadWorker);

          conn = await db.connect();

          window.duckdb = duckdb;
          window.db = db;
          window.conn = conn;

          console.log("DuckDB initialization completed successfully");
          updateInitStatus("‚úÖ DuckDB-WASM initialized successfully!", true);

          return true;
        } catch (error) {
          console.error("DuckDB initialization error:", error);
          updateInitStatus(
            `‚ùå Initialization Error: ${error.message}`,
            false,
            true
          );
          throw error;
        }
      }

      window.exportToParquet = async function () {
        const tableName = document.getElementById("exportTableSelect").value;
        const statusDiv = document.getElementById("exportStatus");

        if (!tableName) {
          statusDiv.innerHTML =
            '<span class="error">Please select a table</span>';
          return;
        }

        try {
          statusDiv.innerHTML =
            '<span class="loading">Generating Parquet file...</span>';

          const outputFile = `${tableName}.parquet`;
          await conn.query(
            `COPY (SELECT * FROM ${tableName}) TO '${outputFile}' (FORMAT 'parquet')`
          );

          const buffer = await db.copyFileToBuffer(outputFile);
          const blob = new Blob([buffer], { type: "application/octet-stream" });

          const a = Object.assign(document.createElement("a"), {
            href: URL.createObjectURL(blob),
            download: outputFile,
          });

          document.body.appendChild(a).click();
          document.body.removeChild(a);

          statusDiv.innerHTML =
            '<span class="success">‚úÖ Parquet file saved successfully</span>';
          setTimeout(() => {
            statusDiv.innerHTML = "";
          }, 3000);
        } catch (error) {
          statusDiv.innerHTML = `<span class="error">Error: ${error.message}</span>`;
        }
      };

      window.exportToCSV = async function () {
        const tableName = document.getElementById("exportTableSelect").value;
        const statusDiv = document.getElementById("exportStatus");

        if (!tableName) {
          statusDiv.innerHTML =
            '<span class="error">Please select a table</span>';
          return;
        }

        try {
          statusDiv.innerHTML =
            '<span class="loading">Generating CSV file...</span>';

          const outputFile = `${tableName}.csv`;
          await conn.query(
            `COPY (SELECT * FROM ${tableName}) TO '${outputFile}' (FORMAT 'csv', HEADER)`
          );

          const buffer = await db.copyFileToBuffer(outputFile);
          const blob = new Blob([buffer], { type: "text/csv" });

          const a = Object.assign(document.createElement("a"), {
            href: URL.createObjectURL(blob),
            download: outputFile,
          });

          document.body.appendChild(a).click();
          document.body.removeChild(a);

          statusDiv.innerHTML =
            '<span class="success">‚úÖ CSV file saved successfully</span>';
          setTimeout(() => {
            statusDiv.innerHTML = "";
          }, 3000);
        } catch (error) {
          statusDiv.innerHTML = `<span class="error">Error: ${error.message}</span>`;
        }
      };

      window.exportQueryResult = async function () {
        if (!lastQueryResult) {
          alert("Please execute a query first");
          return;
        }

        try {
          const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
          const outputFile = `query_result_${timestamp}.csv`;

          await conn.query(
            "CREATE TEMP TABLE temp_export AS " +
              document.getElementById("sqlQuery").value
          );
          await conn.query(
            `COPY temp_export TO '${outputFile}' (FORMAT 'csv', HEADER)`
          );

          const buffer = await db.copyFileToBuffer(outputFile);
          const blob = new Blob([buffer], { type: "text/csv" });

          const a = Object.assign(document.createElement("a"), {
            href: URL.createObjectURL(blob),
            download: outputFile,
          });

          document.body.appendChild(a).click();
          document.body.removeChild(a);

          await conn.query("DROP TABLE temp_export");
        } catch (error) {
          alert(`Export error: ${error.message}`);
        }
      };

      window.saveApiKey = function () {
        const key = document.getElementById("apiKey").value.trim();
        const statusSpan = document.getElementById("apiKeyStatus");

        if (key) {
          apiKey = key;
          localStorage.setItem("gemini_api_key", key);
          statusSpan.innerHTML = '<span class="success"> ‚úÖ Saved</span>';
          setTimeout(() => {
            statusSpan.innerHTML = "";
          }, 3000);
        } else {
          statusSpan.innerHTML =
            '<span class="error"> ‚ùå Please enter a key</span>';
        }
      };

      window.switchTab = function (tabName) {
        document.querySelectorAll(".tab").forEach((t) => {
          t.classList.remove("active");
        });
        document.querySelectorAll(".tab-content").forEach((c) => {
          c.classList.remove("active");
        });

        event.target.classList.add("active");
        document.getElementById(tabName).classList.add("active");

        if (tabName === "tables") {
          refreshTableList();
        }
      };

      window.addEventListener("DOMContentLoaded", async () => {
        const savedKey = localStorage.getItem("gemini_api_key");
        if (savedKey) {
          apiKey = savedKey;
          document.getElementById("apiKey").value = savedKey;
        }

        try {
          await initDuckDB();
        } catch (error) {
          console.error("Failed to initialize DuckDB:", error);
        }
      });

      const dropZone = document.getElementById("dropZone");
      const fileInput = document.getElementById("fileInput");

      dropZone.addEventListener("click", () => fileInput.click());

      dropZone.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropZone.classList.add("drag-over");
      });

      dropZone.addEventListener("dragleave", () => {
        dropZone.classList.remove("drag-over");
      });

      dropZone.addEventListener("drop", (e) => {
        e.preventDefault();
        dropZone.classList.remove("drag-over");
        handleFiles(e.dataTransfer.files);
      });

      fileInput.addEventListener("change", (e) => {
        handleFiles(e.target.files);
      });

      async function handleFiles(files) {
        const resultDiv = document.getElementById("loadResult");
        const fileListDiv = document.getElementById("fileList");

        resultDiv.innerHTML = '<p class="loading">Loading file(s)...</p>';
        fileListDiv.style.display = "block";
        fileListDiv.innerHTML = "";

        try {
          if (!db || !conn) {
            await initDuckDB();
          }

          let successCount = 0;
          let errorCount = 0;

          for (const file of files) {
            const fileName = file.name;
            const fileExt = fileName.split(".").pop().toLowerCase();

            if (!["csv", "parquet"].includes(fileExt)) {
              fileListDiv.innerHTML += `<div class="file-item" style="border-color: #d9534f;">‚ùå ${fileName}: Unsupported format</div>`;
              errorCount++;
              continue;
            }

            try {
              console.log(`Loading file: ${fileName}`);

              const tableName = fileName
                .replace(/\.[^/.]+$/, "")
                .replace(/[^a-zA-Z0-9_]/g, "_")
                .toLowerCase();

              if (fileExt === "csv") {
                const csvData = await file.text();
                await db.registerFileText(fileName, csvData);
                await conn.query(
                  `CREATE OR REPLACE TABLE ${tableName} AS 
                   SELECT * FROM read_csv_auto('${fileName}', header=true, auto_detect=true)`
                );
              } else if (fileExt === "parquet") {
                const arrayBuffer = await file.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);

                await db.registerFileBuffer(fileName, uint8Array);

                await conn.query(
                  `CREATE OR REPLACE TABLE ${tableName} AS 
                   SELECT * FROM '${fileName}'`
                );
              }

              const countResult = await conn.query(
                `SELECT COUNT(*) as count FROM ${tableName}`
              );
              const recordCount = Number(countResult.toArray()[0].count);

              loadedFiles.add(tableName);

              fileListDiv.innerHTML += `
                <div class="file-item">
                  <span>‚úÖ ${fileName} ‚Üí <strong>${tableName}</strong> (${recordCount} records)</span>
                  <div>
                    <button onclick="quickExport('${tableName}', 'parquet')" class="small export">Parquet</button>
                    <button onclick="quickExport('${tableName}', 'csv')" class="small export">CSV</button>
                  </div>
                </div>`;
              successCount++;
            } catch (innerError) {
              console.error(`Error loading ${fileName}:`, innerError);
              fileListDiv.innerHTML += `<div class="file-item" style="border-color: #d9534f;">‚ùå ${fileName}: ${innerError.message}</div>`;
              errorCount++;
            }
          }

          let summaryMessage = "";
          if (successCount > 0 && errorCount === 0) {
            summaryMessage = `<p class="success">‚úÖ Successfully loaded all ${successCount} files</p>`;
          } else if (successCount > 0 && errorCount > 0) {
            summaryMessage = `<p class="info">‚ö†Ô∏è ${successCount} succeeded, ${errorCount} failed</p>`;
          } else {
            summaryMessage = `<p class="error">‚ùå Failed to load files</p>`;
          }

          resultDiv.innerHTML = summaryMessage;
          updateTableSelectors();
        } catch (error) {
          resultDiv.innerHTML = `<p style="color:red;">Error: ${error.message}</p>`;
          console.error("File handling error:", error);
        }
      }

      window.quickExport = async function (tableName, format) {
        try {
          const outputFile = `${tableName}.${format}`;

          if (format === "parquet") {
            await conn.query(
              `COPY (SELECT * FROM ${tableName}) TO '${outputFile}' (FORMAT 'parquet')`
            );
          } else {
            await conn.query(
              `COPY (SELECT * FROM ${tableName}) TO '${outputFile}' (FORMAT 'csv', HEADER)`
            );
          }

          const buffer = await db.copyFileToBuffer(outputFile);
          const blob = new Blob([buffer], {
            type:
              format === "parquet" ? "application/octet-stream" : "text/csv",
          });

          const a = Object.assign(document.createElement("a"), {
            href: URL.createObjectURL(blob),
            download: outputFile,
          });

          document.body.appendChild(a).click();
          document.body.removeChild(a);
        } catch (error) {
          alert(`Export error: ${error.message}`);
        }
      };

      async function updateTableSelectors() {
        try {
          const result = await conn.query("SHOW TABLES");
          const tables = result.toArray();

          const selectors = ["analysisTableSelect", "exportTableSelect"];

          selectors.forEach((selectorId) => {
            const select = document.getElementById(selectorId);
            if (!select) return;

            const currentValue = select.value;
            select.innerHTML = '<option value="">Select a table...</option>';

            tables.forEach((row) => {
              const tableName = row.name;
              const option = document.createElement("option");
              option.value = tableName;
              option.textContent = tableName;
              if (tableName === currentValue) {
                option.selected = true;
              }
              select.appendChild(option);
            });
          });
        } catch (error) {
          console.error("Error updating table selectors:", error);
        }
      }

      window.loadTableAnalysis = async function () {
        const tableName = document.getElementById("analysisTableSelect").value;
        const contentDiv = document.getElementById("analysisContent");

        if (!tableName) {
          contentDiv.innerHTML = "<p>Please select a table</p>";
          return;
        }

        contentDiv.innerHTML = '<p class="loading">Analyzing...</p>';

        try {
          const countResult = await conn.query(
            `SELECT COUNT(*) as count FROM ${tableName}`
          );
          const rowCount = Number(countResult.toArray()[0].count);

          const schemaResult = await conn.query(`DESCRIBE ${tableName}`);
          const columns = schemaResult.toArray();

          // Basic Stats
          let html = `<div class="stat-grid">`;
          html += `<div class="stat-card"><h4>Total Rows</h4><div class="value">${rowCount.toLocaleString()}</div></div>`;
          html += `<div class="stat-card"><h4>Total Columns</h4><div class="value">${columns.length}</div></div>`;
          html += `</div>`;

          // Column Analysis Table
          html += `<h3 style="margin-top: 25px; margin-bottom: 15px;">Column Details</h3>`;
          html += `<div style="overflow-x: auto;">`;
          html += `<table style="width: 100%; min-width: 1400px;">`;
          html += `<thead><tr>`;
          html += `<th style="width: 10%;">Column Name</th>`;
          html += `<th style="width: 7%;">Data Type</th>`;
          html += `<th style="width: 6%;">Rows</th>`;
          html += `<th style="width: 6%;">Nulls</th>`;
          html += `<th style="width: 6%;">Null %</th>`;
          html += `<th style="width: 6%;">Empty Strings</th>`;
          html += `<th style="width: 6%;">N/A Count</th>`;
          html += `<th style="width: 7%;">Unique Values</th>`;
          html += `<th style="width: 7%;">Min</th>`;
          html += `<th style="width: 7%;">Max</th>`;
          html += `<th style="width: 7%;">Avg</th>`;
          html += `<th style="width: 7%;">Std Dev</th>`;
          html += `<th style="width: 14%;">Other Stats</th>`;
          html += `</tr></thead>`;
          html += `<tbody>`;

          for (const col of columns) {
            const colName = col.column_name;
            const colType = col.column_type;

            // Null count
            const nullCountResult = await conn.query(
              `SELECT COUNT(*) as null_count FROM ${tableName} WHERE "${colName}" IS NULL`
            );
            const nullCount = Number(nullCountResult.toArray()[0].null_count);
            const nullPercent =
              rowCount > 0 ? ((nullCount / rowCount) * 100).toFixed(1) : "0";

            // Empty string count
            let emptyStringCount = 0;
            if (
              colType.includes("VARCHAR") ||
              colType.includes("TEXT") ||
              colType.includes("STRING")
            ) {
              try {
                const emptyResult = await conn.query(
                  `SELECT COUNT(*) as empty_count FROM ${tableName} WHERE "${colName}" = ''`
                );
                emptyStringCount = Number(emptyResult.toArray()[0].empty_count);
              } catch (e) {
                console.error(
                  `Error counting empty strings for ${colName}:`,
                  e
                );
              }
            }

            // NA count
            let naCount = 0;
            try {
              const naResult = await conn.query(
                `SELECT COUNT(*) as na_count FROM ${tableName} WHERE UPPER(CAST("${colName}" AS VARCHAR)) IN ('NA', 'N/A')`
              );
              naCount = Number(naResult.toArray()[0].na_count);
            } catch (e) {
              console.error(`Error counting NA values for ${colName}:`, e);
            }

            // Unique value count
            const uniqueResult = await conn.query(
              `SELECT COUNT(DISTINCT "${colName}") as unique_count FROM ${tableName}`
            );
            const uniqueCount = Number(uniqueResult.toArray()[0].unique_count);

            // Start row
            html += `<tr>`;
            html += `<td><strong>${colName}</strong></td>`;
            html += `<td style="font-size: 11px;">${colType}</td>`;
            html += `<td>${rowCount.toLocaleString()}</td>`;
            html += `<td>${nullCount.toLocaleString()}</td>`;
            html += `<td>${nullPercent}%</td>`;
            html += `<td>${emptyStringCount.toLocaleString()}</td>`;
            html += `<td>${naCount.toLocaleString()}</td>`;
            html += `<td>${uniqueCount.toLocaleString()}</td>`;

            // Type-specific stats (min, max, avg, stddev, other)
            let minVal = "-";
            let maxVal = "-";
            let avgVal = "-";
            let stdVal = "-";
            let otherStats = "-";

            if (
              colType.includes("VARCHAR") ||
              colType.includes("TEXT") ||
              colType.includes("STRING")
            ) {
              // String type
              try {
                const lengthResult = await conn.query(
                  `SELECT 
                    MIN(LENGTH("${colName}")) as min_len,
                    MAX(LENGTH("${colName}")) as max_len,
                    ROUND(AVG(LENGTH("${colName}"))) as avg_len
                  FROM ${tableName} WHERE "${colName}" IS NOT NULL`
                );
                const lenStats = lengthResult.toArray()[0];

                minVal = `${lenStats?.min_len || 0} chars`;
                maxVal = `${lenStats?.max_len || 0} chars`;
                avgVal = `${lenStats?.avg_len || 0} chars`;

                const whitespaceResult = await conn.query(
                  `SELECT COUNT(*) as ws_count FROM ${tableName} WHERE "${colName}" != TRIM("${colName}")`
                );
                const whitespaceCount = Number(
                  whitespaceResult.toArray()[0].ws_count
                );

                if (whitespaceCount > 0) {
                  otherStats = `Has Whitespace: ${whitespaceCount}`;
                }
              } catch (e) {
                otherStats = "Stats N/A";
              }
            } else if (
              colType.includes("INTEGER") ||
              colType.includes("DOUBLE") ||
              colType.includes("DECIMAL") ||
              colType.includes("FLOAT") ||
              colType.includes("BIGINT") ||
              colType.includes("NUMERIC")
            ) {
              // Numeric type
              try {
                const statsResult = await conn.query(
                  `SELECT 
                    CAST(MIN("${colName}") AS DOUBLE) as min_val,
                    CAST(MAX("${colName}") AS DOUBLE) as max_val,
                    ROUND(CAST(AVG("${colName}") AS DOUBLE), 2) as avg_val,
                    ROUND(CAST(STDDEV("${colName}") AS DOUBLE), 2) as std_val
                  FROM ${tableName} WHERE "${colName}" IS NOT NULL`
                );
                const stats = statsResult.toArray()[0];

                if (stats && stats.min_val !== null) {
                  minVal = stats.min_val;
                  maxVal = stats.max_val;
                  avgVal = stats.avg_val;
                  stdVal = stats.std_val !== null ? stats.std_val : "-";
                }
              } catch (e) {
                otherStats = "Stats N/A";
              }
            } else if (
              colType.includes("DATE") ||
              colType.includes("TIMESTAMP")
            ) {
              // Date type
              try {
                const dateResult = await conn.query(
                  `SELECT 
                    MIN("${colName}") as min_date,
                    MAX("${colName}") as max_date,
                    COUNT(DISTINCT DATE("${colName}")) as unique_dates
                  FROM ${tableName} WHERE "${colName}" IS NOT NULL`
                );
                const dateStats = dateResult.toArray()[0];

                if (dateStats && dateStats.min_date) {
                  minVal = dateStats.min_date;
                  maxVal = dateStats.max_date;
                  otherStats = `Unique Days: ${dateStats.unique_dates}`;
                }
              } catch (e) {
                otherStats = "Stats N/A";
              }
            } else if (colType.includes("BOOLEAN")) {
              // Boolean type
              try {
                const boolResult = await conn.query(
                  `SELECT 
                    COUNT(CASE WHEN "${colName}" = true THEN 1 END) as true_count,
                    COUNT(CASE WHEN "${colName}" = false THEN 1 END) as false_count
                  FROM ${tableName}`
                );
                const boolStats = boolResult.toArray()[0];
                const trueCount = Number(boolStats.true_count);
                const falseCount = Number(boolStats.false_count);

                otherStats = `TRUE: ${trueCount} (${(
                  (trueCount / rowCount) *
                  100
                ).toFixed(1)}%), FALSE: ${falseCount} (${(
                  (falseCount / rowCount) *
                  100
                ).toFixed(1)}%)`;
              } catch (e) {
                otherStats = "Stats N/A";
              }
            }

            html += `<td>${minVal}</td>`;
            html += `<td>${maxVal}</td>`;
            html += `<td>${avgVal}</td>`;
            html += `<td>${stdVal}</td>`;
            html += `<td style="font-size: 11px;">${otherStats}</td>`;
            html += `</tr>`;
          }

          html += `</tbody>`;
          html += `</table>`;
          html += `</div>`;

          // Sample Data
          html += `<h3 style="margin-top: 30px; margin-bottom: 15px;">Sample Data</h3>`;
          html += `<div style="overflow-x: auto;">`;

          try {
            const sampleResult = await conn.query(
              `SELECT * FROM ${tableName} LIMIT 100`
            );
            const sampleData = sampleResult.toArray();

            if (sampleData.length > 0) {
              const sampleColumns = Object.keys(sampleData[0]);
              html += `<table style="width: 100%;">`;
              html += `<thead><tr>`;
              sampleColumns.forEach((col) => {
                html += `<th>${col}</th>`;
              });
              html += `</tr></thead><tbody>`;

              sampleData.forEach((row) => {
                html += `<tr>`;
                sampleColumns.forEach((col) => {
                  let value = row[col];
                  if (value === null) {
                    value =
                      '<span style="color: #999; font-style: italic;">NULL</span>';
                  } else if (typeof value === "bigint") {
                    value = value.toString();
                  } else if (value instanceof Date) {
                    value = value.toISOString();
                  }
                  html += `<td>${value}</td>`;
                });
                html += `</tr>`;
              });

              html += `</tbody></table>`;
            }
          } catch (e) {
            html += `<p style="color: #999;">Could not retrieve sample data</p>`;
          }

          html += `</div>`;

          contentDiv.innerHTML = html;
        } catch (error) {
          contentDiv.innerHTML = `<p style="color:red;">Error: ${error.message}</p>`;
          console.error("Table analysis error:", error);
        }
      };

      window.loadOverview = window.loadTableAnalysis;
      window.loadDetailedAnalysis = window.loadTableAnalysis;

      window.executeQuery = async function () {
        const query = document.getElementById("sqlQuery").value.trim();
        if (!query) {
          alert("Please enter a query");
          return;
        }

        const resultDiv = document.getElementById("queryResult");
        resultDiv.innerHTML = '<p class="loading">Executing query...</p>';

        try {
          if (!db || !conn) {
            await initDuckDB();
          }

          console.log("Executing query:", query);
          const result = await conn.query(query);
          lastQueryResult = result;
          displayTable(result, resultDiv);
        } catch (error) {
          resultDiv.innerHTML = `<p style="color:red;">Error: ${error.message}</p>`;
        }
      };

      function displayTable(result, container) {
        try {
          let rows;
          if (result.schema && result.batches) {
            rows = arrowResultToObjectArray(result);
          } else {
            rows = result.toArray();
          }

          if (rows.length === 0) {
            container.innerHTML = "<p>No data to display</p>";
            return;
          }

          const columns = Object.keys(rows[0]);
          let html = `<p class="info">Fetched: ${rows.length} rows</p>`;
          html += "<table><thead><tr>";
          columns.forEach((col) => {
            html += `<th>${col}</th>`;
          });
          html += "</tr></thead><tbody>";

          const displayRows = rows.slice(0, 100);
          displayRows.forEach((row) => {
            html += "<tr>";
            columns.forEach((col) => {
              html += `<td>${row[col]}</td>`;
            });
            html += "</tr>";
          });

          html += "</tbody></table>";

          if (rows.length > 100) {
            html += `<p style="color: #666; font-size: 12px; margin-top: 10px;">(Showing the first 100 of ${rows.length} total rows)</p>`;
          }

          container.innerHTML = html;
        } catch (error) {
          container.innerHTML = `<p style="color:red;">Display Error: ${error.message}</p>`;
        }
      }

      function arrowResultToObjectArray(arrowTable) {
        if (!arrowTable.batches || arrowTable.batches.length === 0) return [];

        const colNames = arrowTable.schema.fields.map((f) => f.name);
        const rows = [];

        for (let b = 0; b < arrowTable.batches.length; b++) {
          const batch = arrowTable.batches[b];
          const numRows =
            batch.length || batch.numRows || (batch.getChildAt(0)?.length ?? 0);

          for (let rowIndex = 0; rowIndex < numRows; rowIndex++) {
            const rowObj = {};
            for (let colIndex = 0; colIndex < batch.numCols; colIndex++) {
              const colName = colNames[colIndex];
              const colVector = batch.getChildAt(colIndex);
              rowObj[colName] = colVector.get(rowIndex);
            }
            rows.push(rowObj);
          }
        }
        return rows;
      }

      async function callGemini(prompt) {
        if (!apiKey) {
          throw new Error("API key is not set");
        }

        const response = await fetch(
          `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    {
                      text: prompt,
                    },
                  ],
                },
              ],
              generationConfig: {
                temperature: 0.7,
                maxOutputTokens: 1000,
              },
            }),
          }
        );

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error?.message || "API call error");
        }

        const data = await response.json();
        return data.candidates[0].content.parts[0].text;
      }

      function convertDuckDBData(data) {
        if (Array.isArray(data)) {
          return data.map((row) => convertDuckDBData(row));
        } else if (data && typeof data === "object") {
          const converted = {};
          for (const [key, value] of Object.entries(data)) {
            converted[key] = convertDuckDBData(value);
          }
          return converted;
        } else if (typeof data === "bigint") {
          return data.toString();
        } else if (data instanceof Date) {
          return data.toISOString();
        } else if (
          data &&
          data.constructor &&
          data.constructor.name === "Decimal"
        ) {
          return data.toString();
        }
        return data;
      }

      function bigIntReplacer(key, value) {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      }

      window.analyzeSQLWithGemini = async function () {
        const query = document.getElementById("analysisQuery").value;
        const resultDiv = document.getElementById("integrationResult");
        resultDiv.innerHTML = '<p class="loading">Fetching data...</p>';

        try {
          if (!db || !conn) {
            await initDuckDB();
          }

          const result = await conn.query(query);
          const rawData = result.toArray();

          if (rawData.length === 0) {
            resultDiv.innerHTML = "<p>Query returned no results</p>";
            return;
          }

          const data = convertDuckDBData(rawData);

          resultDiv.innerHTML =
            '<p class="loading">Analyzing with Gemini...</p>';

          const sampleData = data.length > 50 ? data.slice(0, 50) : data;
          const isSampled = data.length > 50;

          const prompt = `Analyze the following data and provide three key insights.
          ${
            isSampled
              ? `(Note: This is a sample of the first 50 out of ${data.length} total records)`
              : ""
          }
          
          Data:\n${JSON.stringify(sampleData, null, 2)}
          
          Please provide a concise answer in English.`;

          const analysis = await callGemini(prompt);

          resultDiv.innerHTML = `
            <h4>üìä Fetched Data (${data.length} rows${
            isSampled ? " - Sampled" : ""
          })</h4>
            <pre>${JSON.stringify(sampleData, null, 2)}</pre>
            <h4>ü§ñ Gemini's Analysis</h4>
            <div>${analysis.replace(/\n/g, "<br>")}</div>
          `;
        } catch (error) {
          resultDiv.innerHTML = `<p style="color:red;">Error: ${error.message}</p>`;
          console.error("Analysis error:", error);
        }
      };

      window.refreshTableList = async function () {
        const contentDiv = document.getElementById("tableListContent");
        contentDiv.innerHTML = '<p class="loading">Loading...</p>';

        try {
          if (!db || !conn) {
            await initDuckDB();
          }

          const result = await conn.query("SHOW TABLES");
          const tables = result.toArray();

          if (tables.length === 0) {
            contentDiv.innerHTML =
              "<p>No tables found. Please upload a file.</p>";
            return;
          }

          let html = `<div class="stat-grid">`;

          for (const table of tables) {
            const tableName = table.name;

            const countResult = await conn.query(
              `SELECT COUNT(*) as count FROM ${tableName}`
            );
            const rowCount = Number(countResult.toArray()[0].count);

            const schemaResult = await conn.query(`DESCRIBE ${tableName}`);
            const colCount = schemaResult.toArray().length;

            html += `<div class="stat-card">`;
            html += `<h4>${tableName}</h4>`;
            html += `<div class="column-detail">${rowCount.toLocaleString()} rows √ó ${colCount} columns</div>`;
            html += `<div style="margin-top: 10px;">`;
            html += `<button onclick="quickExport('${tableName}', 'parquet')" class="small export">Parquet</button>`;
            html += `<button onclick="quickExport('${tableName}', 'csv')" class="small export">CSV</button>`;
            html += `</div>`;
            html += `</div>`;
          }

          html += `</div>`;
          contentDiv.innerHTML = html;
        } catch (error) {
          contentDiv.innerHTML = `<p style="color:red;">Error: ${error.message}</p>`;
          console.error("Table list error:", error);
        }
      };
    </script>
  </body>
</html>
